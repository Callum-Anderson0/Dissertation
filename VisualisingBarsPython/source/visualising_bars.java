/* autogenerated by Processing revision 1286 on 2024-03-12 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import org.jgrapht.*;
import org.jgrapht.graph.*;
import org.jgrapht.graph.concurrent.*;
import org.jgrapht.graph.builder.*;
import org.jgrapht.graph.specifics.*;
import org.jgrapht.alg.decomposition.*;
import org.jgrapht.alg.*;
import org.jgrapht.alg.cycle.*;
import org.jgrapht.alg.partition.*;
import org.jgrapht.alg.planar.*;
import org.jgrapht.alg.flow.*;
import org.jgrapht.alg.flow.mincost.*;
import org.jgrapht.alg.spanning.*;
import org.jgrapht.alg.tour.*;
import org.jgrapht.alg.connectivity.*;
import org.jgrapht.alg.drawing.*;
import org.jgrapht.alg.drawing.model.*;
import org.jgrapht.alg.matching.*;
import org.jgrapht.alg.matching.blossom.v5.*;
import org.jgrapht.alg.similarity.*;
import org.jgrapht.alg.scoring.*;
import org.jgrapht.alg.isomorphism.*;
import org.jgrapht.alg.transform.*;
import org.jgrapht.alg.independentset.*;
import org.jgrapht.alg.clique.*;
import org.jgrapht.alg.densesubgraph.*;
import org.jgrapht.alg.lca.*;
import org.jgrapht.alg.clustering.*;
import org.jgrapht.alg.linkprediction.*;
import org.jgrapht.alg.util.*;
import org.jgrapht.alg.util.extension.*;
import org.jgrapht.alg.color.*;
import org.jgrapht.alg.interfaces.*;
import org.jgrapht.alg.shortestpath.*;
import org.jgrapht.alg.vertexcover.*;
import org.jgrapht.alg.vertexcover.util.*;
import org.jgrapht.traverse.*;
import org.jgrapht.event.*;
import org.jgrapht.util.*;
import org.jgrapht.generate.*;
import org.jgrapht.generate.netgen.*;

import java.util.Collections;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class visualising_bars extends PApplet {

Page p;


int BARS = 4;
int BH = 20;
int BAR_MAX_SIZE = 100;
int BAR_MIN_SIZE = 100;
int BAR_SIZE = 50;
String BAR_GENERATION_STYLE = "RANDOM SIZE";
String VBAR_GENERATION_STYLE = "EVEN RANDOM";
String VBAR_STYLE = "VECTOR";



 public boolean contains(ArrayList<Integer>list,int value){
  boolean found = false;
  for(int i = 0; i < list.size();i++){
    if(list.get(i) == value){
      found = true;
    }
  }
  return found;
}


 public void setup(){
 /* size commented out by preprocessor */; 
 background(0);
 p = new Page();
 p.loadBarsFromCSV("test.csv");
 //p.vbars = p.generateRandomVBars(BARS);
 p.displayVBars();
 //p.AM.populate(p.vbars);
 //p.generateGroups();
 //p.displayGroups();
}

class AdjacencyMatrix{
  int numBars ;
  ArrayList<ArrayList<Integer>> maximalCliques;
  Relation[][] matrix;
  
  AdjacencyMatrix(int numBarsT){
    maximalCliques = new ArrayList<ArrayList<Integer>>();
    numBars = numBarsT;
    matrix = new Relation[numBars][numBars];
  }
  
   public void populate(ArrayList<VBar> vbars){
    for(int i = 0; i < numBars; i++){
      for(int j = i; j < numBars; j++){
        if(j!=i){
          Relation entry = new Relation();
          entry.compare(vbars.get(i),vbars.get(j));
          matrix[i][j] = entry;
          matrix[j][i] = entry.inverse();
        }
      }
    }
  }
  
   public ArrayList<ArrayList<Integer>> defineGroups(){
    ArrayList<ArrayList<Integer>> potentialGroups = new ArrayList<ArrayList<Integer>>();
    for(int i = 0; i < numBars;i++){
      ArrayList<Integer> group = BreadthFirstSearch(i);
      Collections.sort(group);
      boolean found = false;
      for(int j = 0; j < potentialGroups.size();j++){
        if(group.equals(potentialGroups.get(j))){
          found = true;
        }
      }
      if(found == false){
              potentialGroups.add(group);
      }
    }
    return potentialGroups;
  }
  
   public ArrayList<Integer> BreadthFirstSearch(int start){
    ArrayList<Integer> Queue = new ArrayList<Integer>();
    ArrayList<Integer> Visited = new ArrayList<Integer>();
    Queue.add(start);
    Visited.add(start);
    while(Queue.size()>0){

      int current_node = Queue.remove(0);
      ArrayList<ArrayList<Integer>> allNeighbours = findNeighbours(current_node);
      ArrayList<Integer> neighbours = allNeighbours.get(0);
      ArrayList<Integer> nonExpandingNeighbours = allNeighbours.get(1); 
      for(int i = 0; i < neighbours.size();i++){
        if(!Visited.contains(neighbours.get(i))){
          Queue.add(neighbours.get(i));
          Visited.add(neighbours.get(i));
        }
      }
      for(int i = 0; i < nonExpandingNeighbours.size();i++){
        if(!Visited.contains(nonExpandingNeighbours.get(i))){
          Visited.add(nonExpandingNeighbours.get(i));
        }
      }
    }
    return Visited;
  }

   
        
   public ArrayList<ArrayList<Integer>> findNeighbours(int id){
    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();
    ArrayList<Integer> neighbours = new ArrayList<Integer>();
    ArrayList<Integer> nonExpandingNeighbours = new ArrayList<Integer>();
    for(int i = 0; i < numBars; i++){
      if(id!=i){;
        for(int j = 0; j < matrix[id][i].properties.size();j++){
          if(matrix[id][i].properties.get(j).value == true && matrix[id][i].properties.get(j).propagates == 1){
            if(!neighbours.contains(i));
              neighbours.add(i);
          }
          if(matrix[id][i].properties.get(j).value == true && matrix[id][i].properties.get(j).propagates == 2){
          if(!nonExpandingNeighbours.contains(i));
            nonExpandingNeighbours.add(i);
          }
        }
      }
      
    }
    results.add(neighbours);
    results.add(nonExpandingNeighbours);

    return results;
  }
  
  
   public void bronKerboschAlg(){
    ArrayList<ArrayList<Integer>> maximalCliques = new ArrayList<ArrayList<Integer>>();
    boolean[] visited = new boolean[numBars];
    boolean[] candidates = new boolean[numBars];
    boolean[] excluded = new boolean[numBars];
    bronKerbosch(visited,candidates,excluded,0,new ArrayList<Integer>());
    print(maximalCliques);
  }
  
   public void bronKerbosch(boolean[] visited,boolean[]candidates,boolean[] excluded,int pivot,ArrayList<Integer> clique){
    boolean noNeighbours = true;
    for(int i =0 ; i < numBars;i++){
      if(!excluded[i] && !candidates[i]){
        pivot = i;
        noNeighbours = false;
      }
    }
    if(noNeighbours){
      maximalCliques.add(new ArrayList<Integer>(clique));
      //maximalCliques.set(maximalCliques.size()-1,clique);
      return;
    }
    
    for(int i = pivot; i < numBars;i++){
      if(!excluded[pivot] && !candidates[i]){
        boolean isClique = true;
        for(int j = 0; j < numBars; j++){
          if(i!=j){
            if(matrix[i][j].anyPropertyTrue() && !candidates[j]){
              isClique = false;
              break;
            }
          }
        }
        if(isClique){
          candidates[i] = true;
          clique.add(i);
          for(int j = 0; j < numBars;j++){
            if(i!=j){
              if(matrix[i][j].anyPropertyTrue()){
                  candidates[j]=true;
              }
            }
          }
          bronKerbosch(visited,candidates,excluded,pivot+1,clique);
          clique.remove(clique.size()-1);
          candidates[i]=false;
          for(int j = 0; j < numBars;j++){
            if(i!=j){
              if(matrix[i][j].anyPropertyTrue()){
                candidates[j]=false;
              }
            }
          }
          excluded[i]=true;
        }
      }
    }
  }
}


  
class Group{
  int id;
  //ArrayList<Integer> members;
  ArrayList<VBar> members;
  AdjacencyMatrix graph; 
  int c;
  
  Group(int idT,ArrayList<Integer> indices,ArrayList<VBar> allVbars){
    id = idT;
    c = color(random(255),random(255),random(255));
    members = new ArrayList<VBar>();
    
    for(int i = 0; i < indices.size();i++){
      members.add(allVbars.get(indices.get(i)));
    }
    if(members.size() == 1){
      c = color(255);
    }
    groupAnalysis();
    println("Group id:",id);
    textDisplay();
    graph.bronKerboschAlg();
  }
  

  
   public void display(){
    for(int i = 0; i < members.size(); i++){
      members.get(i).display(c);
    }
  }
  
   public void textDisplay(){
    for(int i = 0;i < members.size();i++){
      for(int j = 0;j < members.size();j++){
        if(i!=j){
          graph.matrix[i][j].displayRelation();
        }
      }
    }
  }
  
   public void groupAnalysis(){
    graph = new AdjacencyMatrix(members.size());
    graph.populate(members);    
  }
 
}
class Page{
  ArrayList<Group> groups;
  AdjacencyMatrix AM;
  int barHeight;
  int animationIndex = 0;
  
  ArrayList<VBar> vbars;
  
  Page(){
     vbars = new ArrayList<VBar>();
     groups = new ArrayList<Group>();
     AM = new AdjacencyMatrix(BARS);
  }
  
   public void generateGroups(){
     ArrayList<ArrayList<Integer>> allGroups = p.AM.defineGroups();
     for(int i = 0; i < allGroups.size();i++){
       groups.add(new Group(i,allGroups.get(i),vbars));
     }
  }
  
  
   public ArrayList<VBar> generateRandomVBars(int x){
    ArrayList<VBar> tempBars = new ArrayList<VBar>();
    
    for(int i = 0; i < x;i++){
      PVector start = new PVector();
      PVector end = new PVector();
      VBar candidateVBar;
      if(VBAR_GENERATION_STYLE == "TRUE RANDOM"){
        start = new PVector(random(width),random(height));
        end = new PVector(random(width),random(height));
      }
      if(VBAR_GENERATION_STYLE == "EVEN RANDOM"){
        int randomx = (int)random(BAR_MAX_SIZE,width-BAR_MAX_SIZE);
        int randomy = (int)random(BAR_MAX_SIZE,height-BAR_MAX_SIZE);
        start = new PVector(randomx,randomy);
        PVector randomDirection = PVector.random2D();
        int randomSize = PApplet.parseInt(random(BAR_MIN_SIZE,BAR_MAX_SIZE));
        PVector span = randomDirection.copy().mult(randomSize);
        
        end.set(start.copy().add(span));
        //println(start,span,end);
      }
      candidateVBar = new VBar(i,start,end,"111111");
      tempBars.add(candidateVBar);

    }
    return tempBars;
  }
  
   public void displayVBars(){
    for(int i = 0 ; i < vbars.size();i++){
      vbars.get(i).display(255);
    }
  }
  
   public void displayGroups(){
    for(Group group : groups){
      if(group.members.size()>1){
        group.display();
      }
    }
  }
  
  
  


 
   public void saveBarsToCSV(){
    Table save = new Table();
    save.addColumn("id");
    save.addColumn("start.x");
    save.addColumn("start.y");
    save.addColumn("end.x");
    save.addColumn("end.y");
    for(int i=0; i < vbars.size();i++){
      TableRow newRow = save.addRow();
      newRow.setInt("id",i);
      newRow.setInt("start.x",(int)vbars.get(i).start.x);
      newRow.setInt("start.y",(int)vbars.get(i).start.y);
      newRow.setInt("end.x",(int)vbars.get(i).end.x);
      newRow.setInt("end.y",(int)vbars.get(i).end.x);
    }
    String time = getCurrentDateTime();
    String path = "data/bars" + time +".csv";
    saveTable(save,path);
  }
  
   public void loadBarsFromCSV(String path){
    Table load = new Table();
    BARS = 0;
    load = loadTable(path,"header");
    for(TableRow row: load.rows()){
      BARS++;
      int id = row.getInt("id");
      PVector start = new PVector(row.getInt("start.x"),row.getInt("start.y"));
      PVector end = new PVector(row.getInt("end.x"),row.getInt("end.y"));
      String colour = row.getString("colour");
      VBar entry = new VBar(id,start,end,colour);
      vbars.add(entry);
    }
  }
  

  
   public String getCurrentDateTime() {
    int year = year();
    int month = month();
    int day = day();
    int hour = hour();
    int minute = minute();
    int second = second();
    
    String dateTime = String.format("%04d-%02d-%02d %02d-%02d-%02d", year, month, day, hour, minute, second);
    return dateTime;
}
}
class Property{
  String name;
  String symbol;
  int propagates;
  Boolean value;
  
  Property(String tempName,Boolean tempValue, String tempSymbol, int propT){
    name = tempName;
    symbol = tempSymbol;
    propagates = propT;
    value = tempValue;
  }
  
  public void setValue(boolean v){
   value = v;
 }
 
  public boolean getValue(){
   return value;
 }
 
  public void setName(String n){
   name = n;
 }
  public String getName(){
   return name;
 }
}
class Relation{
  VBar a,b;
  ArrayList<Property> properties;
  
  
  Relation(){
    properties = new ArrayList<Property>();
  }
  
   public void compare(VBar tempA, VBar tempB){
    
    a = tempA;
    b = tempB;
    properties.add(new Property("Intercepting",interceptingCheck(),"A",1));
    properties.add(new Property("Meets",meetsCheck(5),"B",0));
    properties.add(new Property("Near",nearCheck(),"C",0));
    properties.add(new Property("Aligned",alignedCheck(0.8f),"D",0));
    properties.add(new Property("Continues",continuesCheck(5),"E",0));
    properties.add(new Property("Shares Start",shareStartCheck(5),"F",0));
    properties.add(new Property("Preceeds",preceedsCheck(5),"G",0));
    
    //displayRelation();
  }
   public void displayRelation(){
    print(a.id,b.id,":");
    for(int i = 0; i < properties.size();i++){
      print(properties.get(i).getName(),properties.get(i).getValue(),"");
    }
    println();
  }
  
   public ArrayList<String> generateInclusionArray(){
    ArrayList<String> trueSymbols = new ArrayList<String>();
    for(int i = 0; i < properties.size();i++){
      if(properties.get(i).value){
        trueSymbols.add(properties.get(i).symbol);
      }
    }
    return trueSymbols;
  }
  
   public boolean anyPropertyTrue(){
    boolean found = false;
    for(Property p: properties){
      if(p.value){
        found = true;
      }
    }
    return found; 
  }
  
   public boolean interceptingCheck(){
    float d = (a.start.x - a.end.x) * (b.start.y - b.end.y) - (a.start.y - a.end.y) * (b.start.x - b.end.x);
    if (d == 0){
      return false;
    }
    float t = ((a.start.x - b.start.x) * (b.start.y - b.end.y) - (a.start.y - b.start.y) * (b.start.x - b.end.x)) / d;
    
    float u = -((a.start.x - a.end.x) * (a.start.y - b.start.y) - (a.start.y - a.end.y) * (a.start.x - b.start.x)) / d;
    return (t >= 0 && t <= 1 && u >= 0 && u <= 1);
  }
  
   public boolean meetsCheck(int tolerance){
    return dist(a.end.x,a.end.y,b.end.x,b.end.y) < tolerance;
  }
  
   public boolean continuesCheck(int tolerance){
     return dist(a.start.x,a.start.y,b.end.x,b.end.y) < tolerance;
  }
  
   public boolean shareStartCheck(int tolerance){
     return dist(a.start.x,a.start.y,b.start.x,b.start.y) < tolerance;

  }
  
   public boolean nearCheck(){
    float maxDistance = a.span.mag() + b.span.mag();
    float distance = dist(a.start.x,a.start.y,b.start.x,b.start.y);
    return distance < maxDistance;
  }
  
   public boolean alignedCheck(float minimumAlignment){
    //print(a.id,b.id," ");
    float dotProduct = a.span.copy().normalize().dot(b.span.copy().normalize());
    //println(dotProduct);
    return dotProduct > minimumAlignment;
  }
  
   public boolean preceedsCheck(int tolerance){
       return dist(a.end.x,a.end.y,b.start.x,b.start.y) < tolerance;
  }
  
  

   public Relation inverse(){
    Relation inverse = new Relation();
    inverse.compare(b,a);
    return inverse;
  }

  
}
class VBar{
  PVector start;
  PVector end;
  PVector span;
  int id;
  float bearing;
  int colour;
  
  VBar(int tempId, PVector tempStart,PVector tempEnd, String colourT){
    start = tempStart;
    end = tempEnd;
    id = tempId;
    colour = color(unhex(colourT));
    print(unhex(colourT),"\n");
    span = end.copy().sub(start);
    bearing = PVector.angleBetween(span,new PVector(0,-1));
    if(span.x < 0){
      bearing = (PI-bearing)+PI;
    }
    restyle();
  }
  
   public void display(int c){
    stroke(colour);
    strokeWeight(2);
    if(VBAR_STYLE == "VECTOR"){
      circle(start.x,start.y,3);
    }
    line(start.x,start.y,end.x,end.y);
    textSize(15);
    fill(colour);
    text(id,start.x,start.y+15);
  }
  
   public void restyle(){
    if(VBAR_STYLE == "LINE"){
      if(end.x < start.x){
        float temp = end.x;
        end.x = start.x;
        start.x = temp;
      }
      if(end.y < start.y){
        float temp = end.y;
        end.y = start.y;
        start.y = temp;
      }
    }
  }
}


  public void settings() { size(800, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "visualising_bars" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
